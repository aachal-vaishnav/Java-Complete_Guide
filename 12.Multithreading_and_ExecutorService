
# ðŸ“Œ 12. Multi-threading & Executor Service  

## **Topics Covered:**  
1. Intro to Multi-threading  
2. Creating a Thread (`Thread` Class & `Runnable` Interface)  
3. States of a Thread (`New, Runnable, Running, Blocked, Terminated`)  
4. Thread Priority (`setPriority()`, `getPriority()`)  
5. `join()` Method (Thread Synchronization)  
6. `synchronized` Keyword (Mutual Exclusion & Locks)  
7. Thread Communication (`wait()`, `notify()`, `sleep()`, `yield()`)  
8. Intro to Executor Service (`Thread Pool Management`)  
9. Multiple Threads with Executor (`FixedThreadPool`, `CachedThreadPool`)  
10. Returning Futures (`Callable`, `Future`)  

---

## **12.1 What is a Thread?**  
ðŸ“Œ **A thread is a lightweight process that runs independently within a program.**  

âœ… **Why Threads?**  
âœ” Multitasking â†’ Execute multiple tasks **simultaneously**  
âœ” Resource Efficiency â†’ Uses fewer system resources than processes  
âœ” Asynchronous Execution â†’ Handle multiple user requests  

âœ… **Thread Communication Methods:**  
âœ” `wait()`, `notify()`, `notifyAll()` â†’ Allows threads to communicate  
âœ” `sleep(long millis)` â†’ Pauses execution for a given time  
âœ” `yield()` â†’ Suggests scheduler to run another thread  

---

## **12.2 Need for Multi-threading**  
ðŸ“Œ **Why use multiple threads instead of sequential execution?**  

âœ… **Advantages:**  
âœ” **Parallel Execution** â†’ Processes independent tasks simultaneously  
âœ” **Multi-core CPU Utilization** â†’ Prevents CPU from sitting idle  
âœ” **Task Division** â†’ Breaks big tasks into smaller, manageable ones  
âœ” **Responsiveness** â†’ Prevents GUI freezing  

---

## **12.3 Creating a Thread**  
ðŸ“Œ **Two ways to create a thread:**  

### âœ… **Method 1: Extending `Thread` Class**  
```java
class MyThread extends Thread {
    public void run() { System.out.println("Thread running"); }
}
MyThread t1 = new MyThread();
t1.start(); // Starts execution
```

### âœ… **Method 2: Implementing `Runnable` Interface**  
```java
class MyRunnable implements Runnable {
    public void run() { System.out.println("Runnable thread running"); }
}
Thread t2 = new Thread(new MyRunnable());
t2.start();
```
âœ” **Prefer `Runnable` for better flexibility**  

---

## **12.4 States of a Thread**  
ðŸ“Œ **A thread transitions through various states:**  

| **State**          | **Description** |
|-------------------|---------------|
| `NEW`            | Created but not started |
| `RUNNABLE`       | Ready to execute |
| `RUNNING`        | Actively executing |
| `BLOCKED/WAITING` | Waiting for another thread/resource |
| `TERMINATED`     | Completed execution |

âœ… **Example Checking Thread State:**  
```java
Thread t = new Thread();
System.out.println(t.getState()); // Output: NEW
```

---

## **12.5 Thread Priority**  
ðŸ“Œ **Java threads have priority levels from `1` (Lowest) to `10` (Highest).**  

âœ… **Setting Thread Priority:**  
```java
t.setPriority(Thread.MAX_PRIORITY);  // Set priority to 10
System.out.println(t.getPriority()); // Output: 10
```
âœ” **Higher priority increases the chance of execution first but doesn't guarantee it!**  

---

## **12.6 `join()` Method**  
ðŸ“Œ **Ensures a thread completes execution before another starts.**  

âœ… **Example Using `join()`:**  
```java
Thread t1 = new Thread(() -> System.out.println("Thread 1 running"));
Thread t2 = new Thread(() -> System.out.println("Thread 2 running"));

t1.start();
t1.join(); // Ensures t1 completes before t2 starts
t2.start();
```

---

## **12.7 `synchronized` Keyword**  
ðŸ“Œ **Ensures mutual exclusion in multi-threading.**  

âœ… **Example Using `synchronized`:**  
```java
class SharedResource {
    synchronized void printNumbers() {
        for (int i = 1; i <= 5; i++) System.out.println(i);
    }
}
```
âœ” Prevents **race conditions** when accessing shared resources  

---

## **12.8 Thread Communication (`wait()`, `notify()`, `sleep()`)**  
ðŸ“Œ **Threads communicate using synchronization methods.**  

âœ… **Example Using `wait()` & `notify()`:**  
```java
synchronized (obj) {
    obj.wait(); // Pauses execution
    obj.notify(); // Wakes up a waiting thread
}
```

---

## **12.9 Introduction to Executor Service**  
ðŸ“Œ **Manages thread pools efficiently.**  

âœ… **Why Use ExecutorService?**  
âœ” Reduces thread creation overhead  
âœ” Efficient **thread reuse**  
âœ” Handles large numbers of tasks  

âœ… **Example Creating ExecutorService:**  
```java
ExecutorService executor = Executors.newFixedThreadPool(3);
executor.submit(() -> System.out.println("Task running"));
executor.shutdown();
```

---

## **12.10 Returning Futures (`Callable` & `Future`)**  
ðŸ“Œ **Retrieve results from threads using `Future`.**  

âœ… **Example Using `Callable` & `Future`:**  
```java
ExecutorService executor = Executors.newFixedThreadPool(3);
Callable<Integer> task = () -> 5 * 5;
Future<Integer> future = executor.submit(task);
System.out.println(future.get()); // Output: 25
executor.shutdown();
```

---

## **ðŸ”¹ Tasks for Practice:**  
âœ” **Create two threads that print messages independently**  
âœ” **Monitor thread states using `getState()`**  
âœ” **Ensure thread execution order using `join()`**  
âœ” **Simulate a traffic signal using thread synchronization**  
âœ” **Use ExecutorService for managing multiple tasks**  
âœ” **Retrieve results using `Future` & `Callable`**  

---

